<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">
<properties>

    <!--    EntityMessage-->
    <entry key="java.entity.EntityMustHaveOneIdentifierRule.rule.msg">
        <![CDATA[
    实体都拥有一个唯一的标识符
]]>
    </entry>
    <entry key="java.entity.EntityMustHaveOneIdentifierRule.rule.desc">
        <![CDATA[
    说明：实体都拥有一个唯一的标识符将它的个体性和所有其他类型相同或者不同的实体区分开
]]>
    </entry>
    <entry key="java.entity.EntityMustHaveOneIdentifierRule.rule.reference1">
        <![CDATA[
    @领域驱动设计精粹 @P86
        一个实体模型就是一个独立的事物。每个实体都拥有一个唯一的标识符，可以将它的个体性和所有其他类型相同
        或者不同的实体区分开。许多时候，也许应该说绝大多数时候，实体是可变的。也就是说，它的状态会随着时间
        发生变化。不过，一个实体不一定必须是可变的，它也可能是不可变的。将实体与其他建模 工具区分开的主要因
        素是它的唯一性一一即它的个体性。
]]>
    </entry>


    <entry key="java.entity.EntityPackageNameRule.rule.msg">
        <![CDATA[
    实体所在包建议命名为entity
]]>
    </entry>
    <entry key="java.entity.EntityPackageNameRule.rule.desc">
        <![CDATA[
    说明：实体所在包建议命名为entity
]]>
    </entry>
    <entry key="java.entity.EntityPackageNameRule.rule.reference1">
        <![CDATA[
        package com.clsaa.tiad.entity;//the package name should be entity
        @Entity
        public class Person {
        }
]]>
    </entry>


    <entry key="java.entity.EntityShouldInAggregateRule.rule.msg">
        <![CDATA[
    实体应该在聚合范围内
]]>
    </entry>
    <entry key="java.entity.EntityShouldInAggregateRule.rule.desc">
        <![CDATA[
    说明：实体应该在聚合范围内, 即实体应在聚合所在包的子包中
]]>
    </entry>
    <entry key="java.entity.EntityShouldInAggregateRule.rule.reference1">
        <![CDATA[
    @领域驱动设计：软件核心复杂性应对之道,@P82
        AGGREGATE就是一组相关对象的集合，我们把它作为数据修改的单元。每个AGGREGATE都有一个根（root）
        和一个边界（boundary）。边界 定义了AGGREGATE的内部都有什么。根则是AGGREGATE所包含的一个特定
        ENTITY。对AGGREGATE 而言，外部对象只可以引用根，而边界内部的对象之间则可以互相引用。除根以外的
        其他 ENTITY 都有本地标识，但这些标识只在AGGREGATE内部才需要加以区别，因为外部对象除了根ENTITY
        之外看不到其他对象。
]]>
    </entry>

    <entry key="java.entity.EntityOnlyUseInAggregateExceptForRootRule.rule.msg">
        <![CDATA[
    非聚合根实体只能在聚合边界内部相互访问
]]>
    </entry>
    <entry key="java.entity.EntityOnlyUseInAggregateExceptForRootRule.rule.desc">
        <![CDATA[
    说明：非聚合根实体只能在聚合边界内部相互访问
]]>
    </entry>
    <entry key="java.entity.EntityOnlyUseInAggregateExceptForRootRule.rule.reference1">
        <![CDATA[
    @领域驱动设计：软件核心复杂性应对之道,@P82
        对AGGREGATE 而言，外部对象只可以引用根，而边界内部的对象之间则可以互相引用。除根以外的其他 ENTITY
        都有本地标识，但这些标识只在AGGREGATE内部才需要加以区别，因为外部对象除了根ENTITY之 外看不到其他对象。
]]>
    </entry>


    <!--    ValueObjectMessage-->

    <entry key="java.valueobject.ValueObjectEqualsByAttributesRule.rule.msg">
        <![CDATA[
    值对象需实现hashCode和equals方法
]]>
    </entry>
    <entry key="java.valueobject.ValueObjectEqualsByAttributesRule.rule.desc">
        <![CDATA[
    说明：值对象需实现hashCode和equals方法, equals需包含所有属性
]]>
    </entry>
    <entry key="java.valueobject.ValueObjectEqualsByAttributesRule.rule.reference1">
        <![CDATA[
    @领域驱动设计精粹 @P87
        和实体不一样，它没有唯一标识符，而是由值类型封装的属性对比来决定相等性。
]]>
    </entry>


    <entry key="java.valueobject.ValueObjectIsImmutableRule.rule.msg">
        <![CDATA[
    值对象不可变, 属性应由final修饰
]]>
    </entry>
    <entry key="java.valueobject.ValueObjectIsImmutableRule.rule.desc">
        <![CDATA[
    说明：值对象不可变,属性应由final修饰
]]>
    </entry>
    <entry key="java.valueobject.ValueObjectIsImmutableRule.rule.reference1">
        <![CDATA[
    @领域驱动设计精粹 @P87
        一个值对象，或者更简单地说，值（alve），是对一个不变的概念整体所建立的模型。在这个模型中，值就真的只有一个值。
]]>
    </entry>


    <entry key="java.valueobject.ValueObjectNonIdentifierRule.rule.msg">
        <![CDATA[
    值对象没有唯一标识符
]]>
    </entry>
    <entry key="java.valueobject.ValueObjectNonIdentifierRule.rule.desc">
        <![CDATA[
    说明：值对象没有唯一标识符,不应含有identifier属性和注解, id/uniqueCode等属性
]]>
    </entry>
    <entry key="java.valueobject.ValueObjectNonIdentifierRule.rule.reference1">
        <![CDATA[
    @领域驱动设计精粹 @P87
        和实体不一样，它没有唯一标识符，而是由值类型封装的属性对比来决定相等性。
]]>
    </entry>


</properties>
