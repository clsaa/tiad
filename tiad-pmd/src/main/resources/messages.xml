<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">
<properties>

    <!--    EntityMessage-->
    <entry key="java.entity.EntityShouldInABoundedContextRule.rule.msg">
        <![CDATA[
    实体必须包含在限界上下文中
]]>
    </entry>
    <entry key="java.entity.EntityShouldInABoundedContextRule.rule.desc">
        <![CDATA[
    说明：实体必须包含在限界上下文中
]]>
    </entry>
    <entry key="java.entity.EntityShouldInABoundedContextRule.rule.reference1">
        <![CDATA[
    实体必须包含在限界上下文中
]]>
    </entry>


    <entry key="java.entity.EntityMustHaveOneIdentifierRule.rule.msg">
        <![CDATA[
    实体都拥有一个唯一的标识符
]]>
    </entry>
    <entry key="java.entity.EntityMustHaveOneIdentifierRule.rule.desc">
        <![CDATA[
    说明：实体都拥有一个唯一的标识符将它的个体性和所有其他类型相同或者不同的实体区分开
]]>
    </entry>
    <entry key="java.entity.EntityMustHaveOneIdentifierRule.rule.reference1">
        <![CDATA[
    @领域驱动设计精粹 @P86
        一个实体模型就是一个独立的事物。每个实体都拥有一个唯一的标识符，可以将它的个体性和所有其他类型相同
        或者不同的实体区分开。许多时候，也许应该说绝大多数时候，实体是可变的。也就是说，它的状态会随着时间
        发生变化。不过，一个实体不一定必须是可变的，它也可能是不可变的。将实体与其他建模 工具区分开的主要因
        素是它的唯一性一一即它的个体性。
]]>
    </entry>


    <entry key="java.entity.EntityPackageNameRule.rule.msg">
        <![CDATA[
    实体所在包建议命名为entity
]]>
    </entry>
    <entry key="java.entity.EntityPackageNameRule.rule.desc">
        <![CDATA[
    说明：实体所在包建议命名为entity
]]>
    </entry>
    <entry key="java.entity.EntityPackageNameRule.rule.reference1">
        <![CDATA[
        package com.clsaa.tiad.entity;//the package name should be entity
        @Entity
        public class Person {
        }
]]>
    </entry>


    <entry key="java.entity.EntityShouldInAggregateRule.rule.msg">
        <![CDATA[
    实体应该在聚合范围内
]]>
    </entry>
    <entry key="java.entity.EntityShouldInAggregateRule.rule.desc">
        <![CDATA[
    说明：实体应该在聚合范围内, 即实体应在聚合所在包的子包中
]]>
    </entry>
    <entry key="java.entity.EntityShouldInAggregateRule.rule.reference1">
        <![CDATA[
    @领域驱动设计：软件核心复杂性应对之道,@P82
        AGGREGATE就是一组相关对象的集合，我们把它作为数据修改的单元。每个AGGREGATE都有一个根（root）
        和一个边界（boundary）。边界 定义了AGGREGATE的内部都有什么。根则是AGGREGATE所包含的一个特定
        ENTITY。对AGGREGATE 而言，外部对象只可以引用根，而边界内部的对象之间则可以互相引用。除根以外的
        其他 ENTITY 都有本地标识，但这些标识只在AGGREGATE内部才需要加以区别，因为外部对象除了根ENTITY
        之外看不到其他对象。
]]>
    </entry>

    <entry key="java.entity.EntityOnlyUseInAggregateExceptForRootRule.rule.msg">
        <![CDATA[
    非聚合根实体只能在聚合边界内部相互访问
]]>
    </entry>
    <entry key="java.entity.EntityOnlyUseInAggregateExceptForRootRule.rule.desc">
        <![CDATA[
    说明：非聚合根实体只能在聚合边界内部相互访问
]]>
    </entry>
    <entry key="java.entity.EntityOnlyUseInAggregateExceptForRootRule.rule.reference1">
        <![CDATA[
    @领域驱动设计：软件核心复杂性应对之道,@P82
        对AGGREGATE 而言，外部对象只可以引用根，而边界内部的对象之间则可以互相引用。除根以外的其他 ENTITY
        都有本地标识，但这些标识只在AGGREGATE内部才需要加以区别，因为外部对象除了根ENTITY之 外看不到其他对象。
]]>
    </entry>


    <!--    ValueObjectMessage-->
    <entry key="java.valueobject.ValueObjectShouldInABoundedContextRule.rule.msg">
        <![CDATA[
    值对象必须包含在限界上下文中
]]>
    </entry>
    <entry key="java.valueobject.ValueObjectShouldInABoundedContextRule.rule.desc">
        <![CDATA[
    说明：值对象必须包含在限界上下文中
]]>
    </entry>
    <entry key="java.valueobject.ValueObjectShouldInABoundedContextRule值对象必须包含在限界上下文中.rule.reference1">
        <![CDATA[
    值对象必须包含在限界上下文中
]]>
    </entry>

    <entry key="java.valueobject.ValueObjectEqualsByAttributesRule.rule.msg">
        <![CDATA[
    值对象需实现hashCode和equals方法
]]>
    </entry>
    <entry key="java.valueobject.ValueObjectEqualsByAttributesRule.rule.desc">
        <![CDATA[
    说明：值对象需实现hashCode和equals方法, equals需包含所有属性
]]>
    </entry>
    <entry key="java.valueobject.ValueObjectEqualsByAttributesRule.rule.reference1">
        <![CDATA[
    @领域驱动设计精粹 @P87
        和实体不一样，它没有唯一标识符，而是由值类型封装的属性对比来决定相等性。
]]>
    </entry>


    <entry key="java.valueobject.ValueObjectIsImmutableRule.rule.msg">
        <![CDATA[
    值对象不可变, 属性应由final修饰
]]>
    </entry>
    <entry key="java.valueobject.ValueObjectIsImmutableRule.rule.desc">
        <![CDATA[
    说明：值对象不可变,属性应由final修饰
]]>
    </entry>
    <entry key="java.valueobject.ValueObjectIsImmutableRule.rule.reference1">
        <![CDATA[
    @领域驱动设计精粹 @P87
        一个值对象，或者更简单地说，值（alve），是对一个不变的概念整体所建立的模型。在这个模型中，值就真的只有一个值。
]]>
    </entry>


    <entry key="java.valueobject.ValueObjectNonIdentifierRule.rule.msg">
        <![CDATA[
    值对象没有唯一标识符
]]>
    </entry>
    <entry key="java.valueobject.ValueObjectNonIdentifierRule.rule.desc">
        <![CDATA[
    说明：值对象没有唯一标识符,不应含有identifier属性和注解, id/uniqueCode等属性
]]>
    </entry>
    <entry key="java.valueobject.ValueObjectNonIdentifierRule.rule.reference1">
        <![CDATA[
    @领域驱动设计精粹 @P87
        和实体不一样，它没有唯一标识符，而是由值类型封装的属性对比来决定相等性。
]]>
    </entry>

    <!--AggregateRootMessage-->
    <entry key="java.aggregateroot.AggregateRootIsAnEntityRule.rule.msg">
        <![CDATA[
    聚合根必须是一个实体
]]>
    </entry>
    <entry key="java.aggregateroot.AggregateRootIsAnEntityRule.rule.desc">
        <![CDATA[
    说明：聚合根必须是一个实体, 使用@AggregateRoot前先使用@Entity
]]>
    </entry>
    <entry key="java.aggregateroot.AggregateRootIsAnEntityRule.rule.reference1">
        <![CDATA[
    @领域驱动设计：软件核心复杂性应对之道,@P82
    AGGREGATE就是一组相关对象的集合，我 们把它作为数据修改的单元。每个AGGREGATE都有一个根（root）
    和一个边界（boundary）。边界 定义了AGGREGATE的内部都有什么。根则是AGGREGATE所包含的一个特定ENTITY。
]]>
    </entry>

    <!--Aggregate-->
    <entry key="java.aggregate.AggregateShouldHaveOneRootRule.rule.msg">
        <![CDATA[
    聚合必须有且仅有一个根实体
]]>
    </entry>
    <entry key="java.aggregate.AggregateShouldHaveOneRootRule.rule.desc">
        <![CDATA[
    说明：聚合必须有且仅有一个根实体
]]>
    </entry>
    <entry key="java.aggregate.AggregateShouldHaveOneRootRule.rule.reference1">
        <![CDATA[
    @领域驱动设计：软件核心复杂性应对之道,@82;
    AGGREGATE就是一组相关对象的集合，我 们把它作为数据修改的单元。每个AGGREGATE都有一个根（root）和一个边界（boundary）。
]]>
    </entry>

    <entry key="java.aggregate.AggregateShouldHaveOneRootRule.rule.reference2">
        <![CDATA[
    @实现领域驱动设计,@P116
    如果一个或多个技术服务端点，比如 R E S T 资 源 、S O A P 接口或消息类型被用于决定限界上下文的大小，那么上述情况是有可能
    发生的，结果是将导致许多非常小的限界上下文和领域模型，这样的模型中很有 可能只包含一个实体对象，并且该实体作为某个单一聚合的根对象而存在。
]]>
    </entry>

    <entry key="java.aggregate.AggregateShouldInABounderContextRule.rule.msg">
        <![CDATA[
    聚合必须包含在一个限界上下文中
]]>
    </entry>
    <entry key="java.aggregate.AggregateShouldInABounderContextRule.rule.desc">
        <![CDATA[
    说明：聚合必须包含在一个限界上下文中
]]>
    </entry>
    <entry key="java.aggregate.AggregateShouldInABounderContextRule.rule.reference1">
        <![CDATA[
    @领域驱动设计精粹,@P86
    这两个限界上下文中你看到的每一个被圈起来的概念都是一个聚合 。
]]>
    </entry>

    <entry key="java.aggregate.AggregateBounderNonOverlapRule.rule.msg">
        <![CDATA[
    聚合的边界不能重叠
]]>
    </entry>
    <entry key="java.aggregate.AggregateBounderNonOverlapRule.rule.desc">
        <![CDATA[
    说明：聚合的边界不能重叠, 聚合中不能包含其他聚合
]]>
    </entry>
    <entry key="java.aggregate.AggregateBounderNonOverlapRule.rule.reference1">
        <![CDATA[
    所有的聚合最好放到一个包中并列排布
    /domain/aggregate1
    /domain/aggregate2
]]>
    </entry>

    <entry key="java.aggregate.AggregatePackageNameRule.rule.msg">
        <![CDATA[
    聚合所在包名建议为domain.model
]]>
    </entry>
    <entry key="java.aggregate.AggregatePackageNameRule.rule.desc">
        <![CDATA[
    说明：聚合所在包名建议为domain.model
]]>
    </entry>
    <entry key="java.aggregate.AggregatePackageNameRule.rule.reference1">
        <![CDATA[
    聚合所在包名建议为domain.model
]]>
    </entry>


    <!--    BoundedContextMessage-->

    <entry key="java.boundedcontext.BoundedContextNonOverlapRule.rule.msg">
        <![CDATA[
    限界上下文之间没有交集
]]>
    </entry>
    <entry key="java.boundedcontext.BoundedContextNonOverlapRule.rule.desc">
        <![CDATA[
    说明：限界上下文之间没有交集
]]>
    </entry>
    <entry key="java.boundedcontext.BoundedContextNonOverlapRule.rule.reference1">
        <![CDATA[
    @领域驱动设计精粹,P14
        限界上下文是语义和语境上的边界。这意味着边界内的每个代表软件模型的组件都有着特定的含义
        并处理特定的事务。 限界界上下文中的这些组件有特定的上下文语境和语义理据。
]]>
    </entry>


    <entry key="java.boundedcontext.BoundedContextOneApplicationRule.rule.msg">
        <![CDATA[
    限界上下文最好与应用一一对应
]]>
    </entry>
    <entry key="java.boundedcontext.BoundedContextOneApplicationRule.rule.desc">
        <![CDATA[
    说明：限界上下文最好与应用一一对应
]]>
    </entry>
    <entry key="java.boundedcontext.BoundedContextOneApplicationRule.rule.reference1">
        <![CDATA[
    @领域驱动设计精粹,P17
        一个团队应该在一个限界上下文中工作。每个限界上下文应该拥有一个独立的源代码仓库。一个团队可能工作在多
        个限界上下文中，但是多个团队不应该在同一个服界上下文中共事。我们应该采用和分离通用语言同样的方式，千
        净地把不同限界上下文的源代码和数据库模式隔离开。并且，将同一个限界上下文中的验收测试、单元測试和主要
        源代码存放在一起。要明确一个团队只在单一的限界上下文中工作。别给其他团队留下任何机会去修政你的源代码，
        从而引发意外。你的团队控制着源代码和数据库并定义了官方接口，必须通过这些接ロ才可以调用限界上下文。
]]>
    </entry>

    <entry key="java.boundedcontext.BoundedContextOnlyOneCodeRepositoryRule.rule.msg">
        <![CDATA[
    每个限界上下文应该拥有一个独立的源代码仓库
]]>
    </entry>
    <entry key="java.boundedcontext.BoundedContextOnlyOneCodeRepositoryRule.rule.desc">
        <![CDATA[
    说明：每个限界上下文应该拥有一个独立的源代码仓库
]]>
    </entry>
    <entry key="java.boundedcontext.BoundedContextOnlyOneCodeRepositoryRule.rule.reference1">
        <![CDATA[
    @领域驱动设计精粹,P17
        一个团队应该在一个限界上下文中工作。每个限界上下文应该拥有一个独立的源代码仓库。一个团队可能工作在多
        个限界上下文中，但是多个团队不应该在同一个服界上下文中共事。我们应该采用和分离通用语言同样的方式，千
        净地把不同限界上下文的源代码和数据库模式隔离开。并且，将同一个限界上下文中的验收测试、单元測试和主要
        源代码存放在一起。要明确一个团队只在单一的限界上下文中工作。别给其他团队留下任何机会去修政你的源代码，
        从而引发意外。你的团队控制着源代码和数据库并定义了官方接口，必须通过这些接ロ才可以调用限界上下文。
]]>
    </entry>


    <!--SubdomainMessage-->
    <entry key="java.subdomain.SubdomainOneBoundedContextRule.rule.msg">
        <![CDATA[
    子域最好与限界上下文一一对应
]]>
    </entry>
    <entry key="java.subdomain.SubdomainOneBoundedContextRule.rule.desc">
        <![CDATA[
    说明：子域最好与限界上下文一一对应
]]>
    </entry>
    <entry key="java.subdomain.SubdomainOneBoundedContextRule.rule.reference1">
        <![CDATA[
    @领域驱动设计精粹,P52
    正是因为采用了 DDD 的战略设计，团队方能实现最佳的建模成果：限界上下文与子域之间一一对应。
    换句话说，敏捷项目管理核心即一个清晰的限界上下文，也是一个清晰的子域。在某些情况下，一个
    限界上下文中有可能存在多个子域，但这并非是最理想的建模结果
]]>
    </entry>

    <entry key="java.subdomain.SubdomainShouldInABoundedContextRule.rule.msg">
        <![CDATA[
    子域应该包含于限界上下文中
]]>
    </entry>
    <entry key="java.subdomain.SubdomainShouldInABoundedContextRule.rule.desc">
        <![CDATA[
    说明：子域应该包含于限界上下文中
]]>
    </entry>
    <entry key="java.subdomain.SubdomainShouldInABoundedContextRule.rule.reference1">
        <![CDATA[
    @领域驱动设计精粹,P52
    正是因为采用了 DDD 的战略设计，团队方能实现最佳的建模成果：限界上下文与子域之间一一对应。
    换句话说，敏捷项目管理核心即一个清晰的限界上下文，也是一个清晰的子域。在某些情况下，一个
    限界上下文中有可能存在多个子域，但这并非是最理想的建模结果
]]>
    </entry>

    <!--    ContextMappingMessage-->
    <entry key="java.contextmapping.ContextMappingShouldInABoundedContextRule.rule.msg">
        <![CDATA[
    上下文映射应起始或结束于某个限界上下文
]]>
    </entry>
    <entry key="java.contextmapping.ContextMappingShouldInABoundedContextRule.rule.desc">
        <![CDATA[
    说明：上下文映射应起始或结束于某个限界上下文
]]>
    </entry>
    <entry key="java.contextmapping.ContextMappingShouldInABoundedContextRule.rule.reference1">
        <![CDATA[
    @领域驱动设计精粹,P58
        敏捷项目管理核心域必须和其他限界上下文进行集成。这种集成关系在 DDD 中称为上下文映射（Context Mapping）。
        你可以在上面的上下文映射图（Context Map 中看到，Discussion 同时存在于两个限界上下文（Bounded Context）之中。
        回忆一下，这是因为协作上下文是 Discussion 的来源，而敏捷项目管理上下文是 Discussion 的消费者。
        上图中，上下文映射用虚线框里的线段表示（虚线框不是上下文映射的一部分，只是用于强调中间的线段）。
        实际上，连接两个限界上下文之间的这条线段就代表了上下文映射。换句话说，这条线段表示这两个限界上下文之间存在着某种形式的映射，
        包括两个限界上下文之间的集成关系以及团队间的动态关系。
]]>
    </entry>

    <entry key="java.contextmapping.ContextMappingPackageNameRule.rule.msg">
        <![CDATA[
    上下文映射所在包名建议为contextmapping
]]>
    </entry>
    <entry key="java.contextmapping.ContextMappingPackageNameRule.rule.desc">
        <![CDATA[
    说明：上下文映射所在包名建议为contextmapping
]]>
    </entry>
    <entry key="java.contextmapping.ContextMappingPackageNameRule.rule.reference1">
        <![CDATA[
    上下文映射所在包名建议为contextmapping
]]>
    </entry>

    <!--    RepositoryMessage-->
    <entry key="java.repository.RepositoryShouldInABoundedContextRule.rule.msg">
        <![CDATA[
    资源库应包含于限界上下文中
]]>
    </entry>
    <entry key="java.repository.RepositoryShouldInABoundedContextRule.rule.desc">
        <![CDATA[
    说明：资源库应包含于限界上下文中
]]>
    </entry>
    <entry key="java.repository.RepositoryShouldInABoundedContextRule.rule.reference1">
        <![CDATA[
    资源库应包含于限界上下文中
]]>
    </entry>

    <entry key="java.repository.RepositoryOneAggregateRule.rule.msg">
        <![CDATA[
    资源库通常与聚合一一对应
]]>
    </entry>
    <entry key="java.repository.RepositoryOneAggregateRule.rule.desc">
        <![CDATA[
    说明：资源库通常与聚合一一对应
]]>
    </entry>
    <entry key="java.repository.RepositoryOneAggregateRule.rule.reference1">
        <![CDATA[
    资源库通常与聚合一一对应
]]>
    </entry>


    <entry key="java.repository.RepositoryShouldInAggregateRule.rule.msg">
        <![CDATA[
    资源库最好包含于聚合中,可保证aggregate间自由拆分组合,利于架构演进
]]>
    </entry>
    <entry key="java.repository.RepositoryShouldInAggregateRule.rule.desc">
        <![CDATA[
    说明：资源库最好包含于聚合中,可保证aggregate间自由拆分组合,利于架构演进
]]>
    </entry>
    <entry key="java.repository.RepositoryShouldInAggregateRule.rule.reference1">
        <![CDATA[
    资源库最好包含于聚合中,可保证aggregate间自由拆分组合,利于架构演进
]]>
    </entry>

    <entry key="java.repository.RepositoryShouldReturnDomainObjectRule.rule.msg">
        <![CDATA[
    资源库接口返回类型应为领域对象, 在资源库实现中完成持久层对象PO到领域对象DO的转换
]]>
    </entry>
    <entry key="java.repository.RepositoryShouldReturnDomainObjectRule.rule.desc">
        <![CDATA[
    说明：资源库接口返回类型应为领域对象, 在资源库实现中完成持久层对象PO到领域对象DO的转换
]]>
    </entry>
    <entry key="java.repository.RepositoryShouldReturnDomainObjectRule.rule.reference1">
        <![CDATA[
    资源库接口返回类型应为领域对象, 在资源库实现中完成持久层对象PO到领域对象DO的转换
]]>
    </entry>

    <entry key="java.repository.RepositoryHasNoOtherStereotypesRule.rule.msg">
        <![CDATA[
    资源库不应该有其他构造型
]]>
    </entry>
    <entry key="java.repository.RepositoryHasNoOtherStereotypesRule.rule.desc">
        <![CDATA[
    说明：资源库不应该有其他构造型
]]>
    </entry>
    <entry key="java.repository.RepositoryHasNoOtherStereotypesRule.rule.reference1">
        <![CDATA[
    资源库不应该有其他构造型
]]>
    </entry>


    <entry key="java.repository.RepositoryHasAtLeastOneMethodRule.rule.msg">
        <![CDATA[
    资源库至少包含一个方法
]]>
    </entry>
    <entry key="java.repository.RepositoryHasAtLeastOneMethodRule.rule.desc">
        <![CDATA[
    说明：资源库至少包含一个方法
]]>
    </entry>
    <entry key="java.repository.RepositoryHasAtLeastOneMethodRule.rule.reference1">
        <![CDATA[
    资源库至少包含一个方法
]]>
    </entry>

    <entry key="java.repository.RepositoryShouldIsInterfaceRule.rule.msg">
        <![CDATA[
    资源库最好是一个接口,而非具体实现
]]>
    </entry>
    <entry key="java.repository.RepositoryShouldIsInterfaceRule.rule.desc">
        <![CDATA[
    说明：资源库最好是一个接口,而非具体实现
]]>
    </entry>
    <entry key="java.repository.RepositoryShouldIsInterfaceRule.rule.reference1">
        <![CDATA[
    @实现领域驱动设计,P364
        我 们 可 以 将面向集合的资源库看成是一种传统的方式，因为它体现了原生 D D D 资源库模式的基本思想。
        这种资源库模拟了一个集合，或者至少模拟了集合 上的标准接口。此时，从资源库的接口来看，我们根本看不
        出其背后还存在着持久 化机制，也感觉不到我们是在向存储区域中保存数据。
]]>
    </entry>


    <!--DomainServiceMessage-->
    <entry key="java.domainservice.DomainServiceShouldInBoundedContextRule.rule.msg">
        <![CDATA[
    领域服务应该包含于限界上下文中
]]>
    </entry>
    <entry key="java.domainservice.DomainServiceShouldInBoundedContextRule.rule.desc">
        <![CDATA[
    说明：领域服务应该包含于限界上下文中
]]>
    </entry>
    <entry key="java.domainservice.DomainServiceShouldInBoundedContextRule.rule.reference1">
        <![CDATA[
    领域服务应该包含于限界上下文中
]]>
    </entry>


    <entry key="java.domainservice.DomainServiceHasNoOtherStereotypesRule.rule.msg">
        <![CDATA[
    领域服务不应该有其他构造型
]]>
    </entry>
    <entry key="java.domainservice.DomainServiceHasNoOtherStereotypesRule.rule.desc">
        <![CDATA[
    说明：领域服务不应该有其他构造型
]]>
    </entry>
    <entry key="java.domainservice.DomainServiceHasNoOtherStereotypesRule.rule.reference1">
        <![CDATA[
    领域服务不应该有其他构造型
]]>
    </entry>


    <entry key="java.domainservice.DomainServiceHasAtLeastOneMethodRule.rule.msg">
        <![CDATA[
    领域服务至少包含一个方法
]]>
    </entry>
    <entry key="java.domainservice.DomainServiceHasAtLeastOneMethodRule.rule.desc">
        <![CDATA[
    说明：领域服务至少包含一个方法
]]>
    </entry>
    <entry key="java.domainservice.DomainServiceHasAtLeastOneMethodRule.rule.reference1">
        <![CDATA[
    领域服务至少包含一个方法
]]>
    </entry>


    <!--SpecificationMessage-->
    <entry key="java.specification.SpecificationShouldInBoundedContextRule.rule.msg">
        <![CDATA[
    规范应包含于限界上下文中
]]>
    </entry>
    <entry key="java.specification.SpecificationShouldInBoundedContextRule.rule.desc">
        <![CDATA[
    说明：规范应包含于限界上下文中
]]>
    </entry>
    <entry key="java.specification.SpecificationShouldInBoundedContextRule.rule.reference1">
        <![CDATA[
    规范应包含于限界上下文中
]]>
    </entry>

    <entry key="java.specification.SpecificationHasNoOtherStereotypesRule.rule.msg">
        <![CDATA[
    规范不应该有其他构造型
]]>
    </entry>
    <entry key="java.specification.SpecificationHasNoOtherStereotypesRule.rule.desc">
        <![CDATA[
    说明：规范不应该有其他构造型
]]>
    </entry>
    <entry key="java.specification.SpecificationHasNoOtherStereotypesRule.rule.reference1">
        <![CDATA[
    规范不应该有其他构造型
]]>
    </entry>


    <entry key="java.specification.SpecificationHasAtLeastOneMethodRule.rule.msg">
        <![CDATA[
    规范至少包含一个方法
]]>
    </entry>
    <entry key="java.specification.SpecificationHasAtLeastOneMethodRule.rule.desc">
        <![CDATA[
    说明：规范至少包含一个方法
]]>
    </entry>
    <entry key="java.specification.SpecificationHasAtLeastOneMethodRule.rule.reference1">
        <![CDATA[
    规范至少包含一个方法
]]>
    </entry>


    <!--FactoryMessage-->
    <entry key="java.factory.FactoryShouldInBoundedContextRule.rule.msg">
        <![CDATA[
    工厂应该包含于限界上下文中
]]>
    </entry>
    <entry key="java.factory.FactoryShouldInBoundedContextRule.rule.desc">
        <![CDATA[
    说明：工厂应该包含于限界上下文中
]]>
    </entry>
    <entry key="java.factory.FactoryShouldInBoundedContextRule.rule.reference1">
        <![CDATA[
    工厂应该包含于限界上下文中
]]>
    </entry>

    <!--DomainEventMessage-->
    <entry key="java.domainevent.DomainEventShouldInBoundedContextRule.rule.msg">
        <![CDATA[
    领域事件应包含于限界上下文中
]]>
    </entry>
    <entry key="java.domainevent.DomainEventShouldInBoundedContextRule.rule.desc">
        <![CDATA[
    说明：领域事件应包含于限界上下文中
]]>
    </entry>
    <entry key="java.domainevent.DomainEventShouldInBoundedContextRule.rule.reference1">
        <![CDATA[
    领域事件应包含于限界上下文中
]]>
    </entry>


    <entry key="java.domainevent.DomainEventShouldHaveSource.rule.msg">
        <![CDATA[
    领域事件中应记录事件来源
]]>
    </entry>
    <entry key="java.domainevent.DomainEventShouldHaveSource.rule.desc">
        <![CDATA[
    说明：领域事件中应记录事件来源
]]>
    </entry>
    <entry key="java.domainevent.DomainEventShouldHaveSource.rule.reference1">
        <![CDATA[
    领域事件中应记录事件来源
]]>
    </entry>


    <entry key="java.domainevent.DomainEventNameShouldBeVerbRule.rule.msg">
        <![CDATA[
    领域事件一般命名为过去时
]]>
    </entry>
    <entry key="java.domainevent.DomainEventNameShouldBeVerbRule.rule.desc">
        <![CDATA[
    说明：领域事件一般命名为过去时
]]>
    </entry>
    <entry key="java.domainevent.DomainEventNameShouldBeVerbRule.rule.reference1">
        <![CDATA[
    @领域驱动设计精粹,@P114
        领域事件类型的名称应该是对过去发生的事情的陈述，即动词的过去式 。
]]>
    </entry>


    <entry key="java.domainevent.DomainEventMustHaveOneIdentifierRule.rule.msg">
        <![CDATA[
    领域事件需要唯一标识
]]>
    </entry>
    <entry key="java.domainevent.DomainEventMustHaveOneIdentifierRule.rule.desc">
        <![CDATA[
    说明：领域事件需要唯一标识
]]>
    </entry>
    <entry key="java.domainevent.DomainEventMustHaveOneIdentifierRule.rule.reference1">
        <![CDATA[
    @实现领域驱动设计,P264
    这里 ，我们再讨论一下领域事件为什么需要唯一标识。有时，我们需要对不同 的事件进行区分。在创建、发布事件
    的限界上下文中，我们几乎没有理由对不同事 件进行比较。但 是 ，如果我们的确需要对不同的事件进行比较，我们
    应该怎么办 呢？再者，如果此时的事件被设计成了聚合，我们又该怎么办呢？

    对于领域事件来说，使用属性来表示唯一标识似乎已经足够了，就像值对象 一样。使用事件的名字、产生事件的聚合
    标识和事件时间戳已经足以对不同的事 件进行区分了。当领域事件被建模成了聚合 ; 或者我们需要对不同的事件进
    行比较，但是事件 的属性又不足以区分事件时，我们便需要为事件创建唯一标识。当然，还有其他的原 因。

    当我们需要将领域事件发布到外部限界上下文中时，为事件创建唯一标识也 是有必要的。在有些情况下，单条消息可
    能会被多次分发，比如，在消息设施确定 消息发出之前，消息发布器便瘫痪了。不管是什么原因导致了对消息的重新
    分发，消息订阅方都需要检查出重复的 消息，并且将其忽略掉。为了达到这样的目的，有些消息设施在消息头中加人
    了唯 一性的消息标识，此时我们自己的领域模型是不能生成这样的标识的。即便消息 设施不会自动地向消息中加人
    唯一标识，消息的发送方也会向事件本身或者消息 中加人这样的标识信息。不管采用哪种方法，远程的订阅方都有
    机会知道一条消 息是否是重复发送的。
]]>
    </entry>


</properties>
